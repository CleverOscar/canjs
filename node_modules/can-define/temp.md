> If you are brand new to CanJS, we suggest reading its technology overview for background information on what CanJS does and how it works.

Dear Web Enthusiasts,

The humble DoneJS core team is proud to present CanJS 5.0. CanJS 5.0 continues in the direction of CanJS 4.0 to make a JavaScript framework that solves common problems in a straightforward, ergonomic way. The common patterns it solves are:

- Responding to user interactions and updating HTML.
- Routing.
- Retrieving and modifying service data.

CanJS 5.0 makes it easier than ever to build a web application. So turn on your terminal, clean off your keyboard, boot up your browser, alt-command-I (⌥ ⌘I ) your console, and get ready for some fun as we walk through the most important improvements in CanJS 5.0!

Here’s a summary of those improvements:

- Community Driven Development
- JavaScript Module Builds for easier setup and faster learning
- Simplified model mixins
- More powerful and easier to configure can-query-logic
- Webpack support X
- Easier Routing X
- Improved Testing X
- Upgradability X


Simplified Development
 - Even easier setup with ES Module Builds (5.0)
   - Make JS fun again!



## Community Driven Development

As the case with 4.0, all of 5.0's features were directed by you, the users of CanJS through our surveys.

In fact, in 5.0, we finally delivered the most difficult feature requested
from the very first survey: improved set logic.


## JavaScript Module Builds for easier setup and faster learning

> JavaScript modules are [supported in all major browsers](https://caniuse.com/#feat=es6-module)
>
> <cite><a href="https://developers.google.com/web/fundamentals/primers/modules"><i>
> Using JavaScript modules on the web</i></a> by Addy Asmani and Mathias Bynens</cite>

CanJS 5.0's individual libraries can now be imported as named exports from a JavaScript module like this:

```js
import {Component, DefineMap, route, realtimeRestModel} from "can";
```

Instead of how these had to be imported in 4.0:

```js
import Component from "can-component";
import DefineMap from "can-define/map/map";
import route from "can-route";
import realtimeRestModel from "can-connect/can/base-map/base-map";
```

Using CanJS as a JavaScript module is what we encourage
now when setting up CanJS. This has two benefits:

1. __Easier setup.__

   Previously, you would need to install 6 different packages:

   ```
   npm i can-component can-connect can-define can-route can-set can-stache
   ```

   Now you install one:

   ```
   npm i can
   ```

   Or if you are building a site with just JavaScript modules, import from
   the `core.mjs` or `ecosystem.mjs` bundles:

   ```html
   <script type="module">
   import {Component, DefineMap, route, realtimeRestModel} from "//unpkg.com/can/core.mjs";
   </script>
   ```

2. __Faster Learning.__

   Using CanJS with a module loader like webpack or StealJS works nearly identical as
   using native JavaScript modules (only the paths are different). This allowed
   us to make my favorite new feature of CanJS - "Run in your browser" buttons
   on our code samples:

   > IMAGE OF RUN IN YOUR BROWSER

   We've only begun to update our code samples to use this feature, but we
   feel it will greatly improve how easy it is to learn the framework.

## Simplified model mixins  

CanJS 5.0 adds three model mixins designed to make it easy as possible to retrieve and modify service data:

- [restModel](https://canjs.com/doc/can-rest-model.html) - For basic create, read, update, and delete (CRUD) operations.
- [realtimeRestModel](https://canjs.com/doc/can-realtime-rest-model.html) - Adds automatic list management
  to `restModel`. When items are created, updated, or deleted, `realtimeRestModel` will automatically insert, move, or
  remove items in lists based on the queries used to request the list. __realtimeRestModel is crazy helpful even if you aren't
  using push notifications__.
- [superModel](https://canjs.com/doc/can-super-model.html) - Adds the kitchen sink to `realtimeRestModel`:
  [fall-through localStorage caching](https://canjs.com/doc/can-connect/fall-through-cache/fall-through-cache.html), [request consolidation](https://canjs.com/doc/can-connect/data/combine-requests/combine-requests.html), and [reference types](https://canjs.com/doc/can-connect/can/ref/ref.html).

For example, to connect an observable data type and observable list type to a restful URL is as easy as:

```js
import {restModel, DefineMap, DefineList } from "can";

// Defines the observable Todo type and its properties
const Todo = DefineMap.extend("Todo",{

    // `id` values must be unique.
    id: { type: "number", identity: true },
    complete: { type: "boolean", default: false },
    dueDate: "date",
    name: "string"
});

// Defines an observable list of Todo instances and its methods
Todo.List = DefineList.extend("TodoList",{
    "#": Todo,

    // A helper method to complete every todo in the list.
    completeAll(){
        return this.forEach((todo) => { todo.complete = true; });
    }
});

// Mixes in methods on `Todo` useful for
// creating, retrieving, updating and deleting
// data at the url provided.
restModel({
    Map: Todo,
    url: "/api/todos/{id}"
});
```

Now `Todo` has methods to get and manipulate data such as:

<table>
<tr>
<td>

Retrieve an `Todo.List` from the server.

</td>
<td>

```js
Todo.getList({filter: {complete: true}})
```

</td>
</tr>
<tr>
<td>

Retrieve a single todo from the server.

</td>
<td>

```js
Todo.get({id: 5})
```

</td>
</tr>
<tr>
<td>

Create a todo by POSTing its data to the server.

</td>
<td>

```js
var todo = new Todo({name: "learn CanJS"})
todo.save()
```

</td>
</tr>
<tr>
<td>

Update a todo by PUTing its data to the server.

</td>
<td>

```js
todo.complete = true;
todo.save();
```

</td>
</tr>
<tr>
<td>

Destroy a todo by DELETing its data on the server.

</td>
<td>

```js
todo.destroy();
```

</td>
</tr>
</table>

While `restModel` is great for simple CRUD behavior, it doesn't include automatic list management, CanJS's best
and most original data-modeling feature.  Fortunately, that got a huge upgrade that we'll explore in the next section.

## Simplified Query Logic

CanJS 5.0 introduces a rewrite of the [can-set] library that provided automatic list management and several
other advanced modeling features. It is replaced with the more powerful and easier to configure
[can-query-logic](https://canjs.com/doc/can-query-logic.html). The following goes over what [can-query-logic](https://canjs.com/doc/can-query-logic.html) does and then shows its improvements
over [can-set].

### Background on query logic and set theory

Before showing how [can-query-logic](https://canjs.com/doc/can-query-logic.html) improves [can-set].

[can-query-logic](https://canjs.com/doc/can-query-logic.html) (and [can-set] before it) provide an understanding of what the parameters used to retrieve a list of data represent.

For example, one might request a list of `todos` like:

```js
Todo.getList({
    filter: {complete: true},
    sort: "name"
});
```

The object passed to `getList` is a query. This specific query is for requesting completed todos and have the todos sorted by their name. A QueryLogic instance understands what a Query represents. For example, it can filter records (like a database) that match a particular query:

```js
var todos = [
  { id: 1, name: "learn CanJS",   complete: true  },
  { id: 2, name: "wash the car",  complete: false },
  { id: 3, name: "do the dishes", complete: true  }
]

var queryLogic = new QueryLogic();

var result = queryLogic.filterMembers({
  filter: {complete: true}
}, todos);

result //-> [
//  { id: 3, name: "do the dishes", complete: true  },
//  { id: 1, name: "learn CanJS",   complete: true  }
//]
```

But QueryLogic goes beyond common database functionality. It supports set-logic comparisons of these queries:

```js
var completedTodosQuery = {filter: {complete: false}};
var allTodosQuery = {};
var remainingTodosQuery = queryLogic.difference(allTodosQuery, completedTodosQuery);

remainingTodosQuery //-> {filter: {complete: {$ne: false}}}
```

This awareness helps other libraries like [can-connect] and [can-fixture] provide
automatic list management, caching and other behaviors.

### Improvements from [can-set]

[can-query-logic](https://canjs.com/doc/can-query-logic.html) is easier to configure and more powerful than [can-set].

#### Easier to configure

Previously, building a model almost always required:

- defining an observable type
- configuring a set.Algebra
- configuring a connection

It looked something like:

```js
const Todo = DefineMap.extend({
    id: "number",
    name: "string",
    complete: "boolean"
});

Todo.List = DefineList.extend({
    "#": Todo
});

const todoAlgebra = new set.Algebra(
    set.props.id("id"),
    set.props.boolean("complete")
);

connect([...behaviors...],{
    url: "/todos/{id}"
    Map: Todo,
    algebra: todoAlgebra
});
```

Notice how defining `complete` as a `boolean` happened twice? With [can-query-logic](https://canjs.com/doc/can-query-logic.html)
the configuration comes from the type itself:

```js
import {DefineMap, DefineList, realtimeRestModel} from "can";

const Todo = DefineMap.extend({
    id: {identity: true, type: "number"},
    name: "string",
    complete: "boolean"
});

Todo.List = DefineList.extend({
    "#": Todo
});

realtimeRestModel({
    url: "/todos/{id}"
    Map: Todo
})
```

Taking the configuration from the type itself means that if your server supports
the [default query format](https://canjs.com/doc/can-query-logic/query.html) you likely don't
have to configure a `QueryLogic` anymore.

The [default query format](https://canjs.com/doc/can-query-logic/query.html) follows the [Fetching Data JSONAPI specification](http://jsonapi.org/format/#fetching).  It looks like:

```js
{
    // Selects only the todos that match.
    filter: {
        complete: {$in: [false, null]}
    },
    // Sort the results of the selection
    sort: "-name",
    // Selects a range of the sorted result
    page: {start: 0, end: 19}
}
```

There's:

- a filter property for filtering records,
- a sort property for specifying the order to sort records, and
- a page property that selects a range of the sorted result. The range indexes are inclusive.

If your service layer doesn't match [default query format](https://canjs.com/doc/can-query-logic/query.html),
that's ok, we've made it far easier to configure `QueryLogic` to understand your service layer. You simply create
a `new QueryLogic` with your type and functions that translate back and forth from your format to the
[default query format](https://canjs.com/doc/can-query-logic/query.html).  For example, if your format uses `page.limit`
and `page.skip` instead of `page.start` and `page.end`, your configuration might look like:

```js
import {DefineMap, DefineList, realtimeRestModel, QueryLogic} from "can";

const Todo = DefineMap.extend({
    id: {identity: true, type: "number"},
    name: "string",
    complete: "boolean"
});

Todo.List = DefineList.extend({
    "#": Todo
});

const todoQueryLogic = new QueryLogic(Todo,{
    toQuery(params) {
        if(params.page) {
            params.page.start = params.page.skip || 0;
            params.page.end = params.page.start + params.page.limit - 1;
            delete params.page.skip;
            delete params.page.limit;
        }
        return params;
    },
    toParams(query) {
        if(params.page) {
            params.page.skip = params.page.start;
            params.page.limit = params.page.end - params.page.start + 1;
            delete params.page.start;
            delete params.page.end;
        }
        return query;
    }
})

realtimeRestModel({
    url: "/todos/{id}"
    Map: Todo,
    queryLogic: todoQueryLogic
})
```

The nice thing here is that the `toQuery` and `toLogic` functions will typically be re-used across an
entire application's models. They can be created (and hopefully open sourced) for every different
service layer.  For example, we created a [FeatherJS converter](https://github.com/canjs/feathers-query-logic/blob/master/feathers-query-logic.js) that can be used as follows:

```js
import feathersFormat from "feathers-query-logic";
import {DefineMap, DefineList, realtimeRestModel, QueryLogic} from "can";

const Todo = DefineMap.extend({
    id: {identity: true, type: "number"},
    name: "string",
    complete: "boolean"
});

Todo.List = DefineList.extend({
    "#": Todo
});

const todoQueryLogic = new QueryLogic(Todo,feathersFormat);

realtimeRestModel({
    url: "/todos/{id}"
    Map: Todo,
    queryLogic: todoQueryLogic
})
```

Finally, defining special filtering behavior, while not easy, is much easier to understand than
defining special behavior with [can-set] and it is much better [documented](https://canjs.com/doc/can-query-logic.html#Definingfilterpropertieswithspeciallogic).

#### More Powerful

[can-query-logic] adds:

- Mongo style comparison operators
- Mongo style `$and` and `$or` operators
- Maybe types are supported
- Date comparisons are supported

##### Mongo style comparison operators

[can-query-logic] supports [MongoDB style comparison operators](https://canjs.com/doc/can-query-logic/comparison-operators.html) out of the box:

```js
import {QueryLogic} from "can";

var queryLogic = new QueryLogic();

queryLogic.filterMembers({
    filter: {
        age: {$gt: 21}
    },
    sort: "name"
},[
    {id: 1, name: "Justin", age: 36},
    {id: 2, name: "Payal", age: 35},
    {id: 3, name: "Ramiya", age: 3},
    {id: 4, name: "Bohdi", age: 0}
    ...
]) //-> [{id: 1, name: "Justin", age: 36},{id: 2, name: "Payal", age: 35}]
```

##### Mongo style `$and` and `$or` operators

Also, `$or` and `$and` are also supported:

```js
import {QueryLogic} from "can";

var queryLogic = new QueryLogic();

// what's not GreaterThan Justin and LessThan Payal?
queryLogic.difference({},{
    filter: {
        name: {
            $gt: "Justin",
            $lt: "Payal"
        }
    }
})
// Everything LessThanEqual Justin OR GreaterThanEqual Payal
//-> {
//    filter: {
//      $or: [
//        {name: {$lte: "Justin"}},
//        {name: {$gte: "Payal"}}
//      ]
//    }    
// }
```

##### Maybe types are supported

DefineMap's properties support `null` and `undefined` values.  For example,
the following `Todo`'s `name` and `complete`  properties' supports `null` and `undefined` values:

```js
const Todo = DefineMap.extend({
    id: {type: "number", identity: true},
    name: "string",
    complete: "boolean"
});

var todo = new Todo({name: null, complete: null});
todo.name     //-> null
todo.complete //-> null
```

QueryLogic won't forget about `null` and `undefined` values:

```js
import {QueryLogic} from "can";

var todoQueryLogic = new QueryLogic(Todo);

// what's not GreaterThan Justin and LessThan Payal?
todoQueryLogic.difference({},{
    filter: {
        name: {
            $gt: "Justin",
            $lt: "Payal"
        }
    }
})
// Everything
//   LessThanEqual Justin OR
//   GreaterThanEqual Payal OR
//   null OR undefined
//-> {
//    filter: {
//      $or: [
//        {name: {$lte: "Justin"}},
//        {name: {$gte: "Payal"}},
//        {name: {$in: [null, undefined]}}
//      ]
//    }    
// }
```

##### Date comparisons are supported

Date types are supported out of the box:

```js
import {DefineMap, QueryLogic} from "can";

const Todo = DefineMap.extend({
    id: {type: "number", identity: true},
    name: "string",
    dueDate: "date"
});

var todoQueryLogic = new QueryLogic(Todo);

todoQueryLogic.filterMembers({
    filter: {
        dueDate: {$gt: "2018-05-01"}
    },
    sort: "name"
},[
    {id: 1, name: "gas", dueDate: "Wed Apr 04 2018 10:00:00 GMT-0500"}
    {id: 2, name: "dishes", dueDate: "Wed Apr 18 2018 10:00:00 GMT-0500"},
    {id: 3, name: "clean saber", dueDate: "Fri May 04 2018 19:00:00 GMT-0500"},
    {id: 4, name: "lawn", dueDate: "Thu Jun 28 2018 19:00:00 GMT-0500"},
    ...
]) //-> [{id: 3, name: "clean saber",...},{id: 4, name: "lawn",...}]
```

`can-query-logic` will work with dates passed as `Date` instances, strings parseable by `Date.parse`
or the number of milliseconds since January 1, 1970, 00:00:00 UTC.
